{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Injectable, Inject, NgModule } from '@angular/core';\n\n/**\n * Represents a scrolling action\n */\nclass PageScrollInstance {\n  /**\n   * Private constructor, requires the properties assumed to be the bare minimum.\n   * Use the factory methods to create instances:\n   *      {@link PageScrollService#create}\n   */\n  constructor(pageScrollOptions) {\n    /**\n     * These properties will be set/manipulated if the scroll animation starts\n     */\n    /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n    this.startScrollPosition = 0;\n    /* Whether an interrupt listener is attached to the body or not */\n    this.interruptListenersAttached = false;\n    /* References to the timer instance that is used to perform the scroll animation to be\n     able to clear it on animation end*/\n    this.timer = null;\n    if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n      pageScrollOptions.scrollViews = [pageScrollOptions.document.documentElement, pageScrollOptions.document.body, pageScrollOptions.document.body.parentNode];\n      this.isInlineScrolling = false;\n    } else {\n      this.isInlineScrolling = true;\n    }\n    this.pageScrollOptions = pageScrollOptions;\n  }\n  static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n    const body = pageScrollOptions.document.body;\n    const docEl = pageScrollOptions.document.documentElement;\n    const windowPageYOffset = pageScrollOptions.document.defaultView && pageScrollOptions.document.defaultView.pageYOffset || undefined;\n    const windowPageXOffset = pageScrollOptions.document.defaultView && pageScrollOptions.document.defaultView.pageXOffset || undefined;\n    const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n    const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n    const clientTop = docEl.clientTop || body.clientTop || 0;\n    const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n    if (scrollTargetElement === undefined || scrollTargetElement === null) {\n      // No element found, so return the current position to not cause any change in scroll position\n      return {\n        top: scrollTop,\n        left: scrollLeft\n      };\n    }\n    const box = scrollTargetElement.getBoundingClientRect();\n    const top = box.top + scrollTop - clientTop;\n    const left = box.left + scrollLeft - clientLeft;\n    return {\n      top: Math.round(top),\n      left: Math.round(left)\n    };\n  }\n  static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n    const position = {\n      top: scrollTargetElement.offsetTop,\n      left: scrollTargetElement.offsetLeft\n    };\n    if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n      const accumulatedParentsPos = {\n        top: 0,\n        left: 0\n      };\n      // not named window to make sure we're not getting the global window variable by accident\n      const theWindow = scrollTargetElement.ownerDocument.defaultView;\n      let parentFound = false;\n      // Start parent is the immediate parent\n      let parent = scrollTargetElement.parentElement;\n      // Iterate upwards all parents\n      while (!parentFound && parent !== undefined && parent !== null) {\n        if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n          accumulatedParentsPos.top += parent.offsetTop;\n          accumulatedParentsPos.left += parent.offsetLeft;\n        }\n        // Next iteration\n        parent = parent.parentElement;\n        parentFound = parent === pageScrollOptions.scrollViews[0];\n      }\n      if (parentFound) {\n        // Only use the results if we found the parent, otherwise we accumulated too much anyway\n        position.top += accumulatedParentsPos.top;\n        position.left += accumulatedParentsPos.left;\n      } else {\n        /* TODO Uncomment\n        if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n          console.warn('Unable to find nested scrolling targets parent!');\n        }*/\n      }\n    }\n    return position;\n  }\n  getScrollPropertyValue(scrollingView) {\n    if (!this.pageScrollOptions.verticalScrolling) {\n      return scrollingView.scrollLeft;\n    }\n    return scrollingView.scrollTop;\n  }\n  getScrollClientPropertyValue(scrollingView) {\n    if (!this.pageScrollOptions.verticalScrolling) {\n      return scrollingView.clientWidth;\n    }\n    return scrollingView.clientHeight;\n  }\n  /**\n   * Extract the exact location of the scrollTarget element.\n   *\n   * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n   * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n   *\n   */\n  extractScrollTargetPosition() {\n    const scrollTargetElement = this.getScrollTargetElement();\n    if (scrollTargetElement === null || scrollTargetElement === undefined) {\n      // Scroll target not found\n      return {\n        top: NaN,\n        left: NaN\n      };\n    }\n    if (this.isInlineScrolling) {\n      return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n    return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n  }\n  /**\n   * Get the top offset of the scroll animation.\n   * This automatically takes the offset location of the scrolling container/scrolling view\n   * into account (for nested/inline scrolling).\n   */\n  getCurrentOffset() {\n    return this.pageScrollOptions.scrollOffset;\n  }\n  /**\n   * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n   * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n   *          false if it failed for all ScrollViews, meaning that we should stop the animation\n   *          (probably because we're at the end of the scrolling region)\n   */\n  setScrollPosition(position) {\n    // Set the new scrollTop/scrollLeft to all scrollViews elements\n    return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n      const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n      if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n        const scrollDistance = Math.abs(startScrollPropertyValue - position);\n        // The movement we need to perform is less than 2px\n        // This we consider a small movement which some browser may not perform when\n        // changing the scrollTop/scrollLeft property\n        // Thus in this cases we do not stop the scroll animation, although setting the\n        // scrollTop/scrollLeft value \"fails\"\n        const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n        if (!this.pageScrollOptions.verticalScrolling) {\n          scrollingView.scrollLeft = position;\n        } else {\n          scrollingView.scrollTop = position;\n        }\n        // Return true if setting the new scrollTop/scrollLeft value worked\n        // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n        // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n        // set due to dpi or rounding irregularities)\n        if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n          return true;\n        }\n      }\n      return oneAlreadyWorked;\n    }, false);\n  }\n  /**\n   * Trigger firing a animation finish event\n   * @param value Whether the animation finished at the target (true) or got interrupted (false)\n   */\n  fireEvent(value) {\n    if (this.pageScrollOptions.scrollFinishListener) {\n      this.pageScrollOptions.scrollFinishListener.emit(value);\n    }\n  }\n  /**\n   * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n   * will be called if any of the attached events is fired.\n   *\n   * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n   */\n  attachInterruptListeners(interruptReporter) {\n    if (this.interruptListenersAttached) {\n      // Detach possibly existing listeners first\n      this.detachInterruptListeners();\n    }\n    this.interruptListener = event => {\n      interruptReporter.report(event, this);\n    };\n    this.pageScrollOptions.interruptEvents.forEach(event => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n    this.interruptListenersAttached = true;\n  }\n  /**\n   * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n   * interrupt\" events.\n   */\n  detachInterruptListeners() {\n    this.pageScrollOptions.interruptEvents.forEach(event => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n    this.interruptListenersAttached = false;\n  }\n  getScrollTargetElement() {\n    if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n      const targetSelector = this.pageScrollOptions.scrollTarget;\n      if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n        // It's an id selector and a valid id, as it does not contain any white space characters\n        return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n      }\n      return this.pageScrollOptions.document.querySelector(targetSelector);\n    }\n    return this.pageScrollOptions.scrollTarget;\n  }\n}\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst defaultPageScrollConfig = {\n  _interval: 10,\n  _minScrollDistance: 2,\n  _logLevel: 1,\n  namespace: 'default',\n  verticalScrolling: true,\n  duration: 1250,\n  scrollOffset: 0,\n  advancedInlineOffsetCalculation: false,\n  interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n  interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n  interruptible: true,\n  scrollInView: true,\n  easingLogic: (t, b, c, d) => {\n    // Linear easing\n    return c * t / d + b;\n  }\n};\nclass PageScrollService {\n  constructor(customConfig) {\n    this.runningInstances = [];\n    this.onInterrupted = {\n      report: (event, pageScrollInstance) => {\n        if (!pageScrollInstance.pageScrollOptions.interruptible) {\n          // Non-interruptible anyway, so do not stop anything\n          return;\n        }\n        let shouldStop = true;\n        if (event.type === 'keyup') {\n          // Only stop if specific keys have been pressed, for all others don't stop anything\n          if (this.config.interruptKeys.indexOf(event.key) === -1) {\n            // The pressed key is not in the list of interrupting keys\n            shouldStop = false;\n          }\n        } else if (event.type === 'mousedown') {\n          // For mousedown events we only stop the scroll animation of the mouse has\n          // been clicked inside the scrolling container\n          if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n            // Mouse clicked an element which is not inside any of the the scrolling containers\n            shouldStop = false;\n          }\n        }\n        if (shouldStop) {\n          this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        }\n      }\n    };\n    this.config = {\n      ...defaultPageScrollConfig,\n      ...customConfig\n    };\n  }\n  stopInternal(interrupted, pageScrollInstance) {\n    const index = this.runningInstances.indexOf(pageScrollInstance);\n    if (index >= 0) {\n      this.runningInstances.splice(index, 1);\n    }\n    if (pageScrollInstance.interruptListenersAttached) {\n      pageScrollInstance.detachInterruptListeners();\n    }\n    if (pageScrollInstance.timer) {\n      // Clear/Stop the timer\n      clearInterval(pageScrollInstance.timer);\n      // Clear the reference to this timer\n      pageScrollInstance.timer = undefined;\n      pageScrollInstance.fireEvent(!interrupted);\n      return true;\n    }\n    return false;\n  }\n  create(options) {\n    return new PageScrollInstance({\n      ...this.config,\n      ...options\n    });\n  }\n  /**\n   * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n   *\n   * This is the core functionality of the whole library.\n   */\n  // tslint:disable-next-line:cyclomatic-complexity\n  start(pageScrollInstance) {\n    // Merge the default options in the pageScrollInstance options\n    pageScrollInstance.pageScrollOptions = {\n      ...this.config,\n      ...pageScrollInstance.pageScrollOptions\n    };\n    // Stop all possibly running scroll animations in the same namespace\n    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n    if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n      // No scrollViews specified, thus we can't animate anything\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n      }\n      return;\n    }\n    let startScrollPositionFound = false;\n    let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]);\n    // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n    pageScrollInstance.startScrollPosition = 0;\n    // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n    pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n      if (scrollingView === undefined || scrollingView === null) {\n        return;\n      }\n      // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n      // or \"scrollLeft\" property that is not undefined and unequal to 0\n      const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n      if (!startScrollPositionFound && scrollPosition) {\n        // We found a scrollingView that does not have scrollTop or scrollLeft 0\n        // Return the scroll position value, as this will be our startScrollPosition\n        pageScrollInstance.startScrollPosition = scrollPosition;\n        startScrollPositionFound = true;\n        // Remember te scrollRange of this scrollingView\n        scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n      }\n    });\n    const pageScrollOffset = pageScrollInstance.getCurrentOffset();\n    // Calculate the target position that the scroll animation should go to\n    const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n    pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n    // Calculate the distance we need to go in total\n    pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n    if (isNaN(pageScrollInstance.distanceToScroll)) {\n      // We weren't able to find the target position, maybe the element does not exist?\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        console.log('Scrolling not possible, as we can\\'t find the specified target');\n      }\n      pageScrollInstance.fireEvent(false);\n      return;\n    }\n    // We're at the final destination already\n    // OR we need to scroll down but are already at the end\n    // OR we need to scroll up but are at the top already\n    const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;\n    // Check how long we need to scroll if a speed option is given\n    // Default executionDuration is the specified duration\n    pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;\n    // Maybe we need to pay attention to the speed option?\n    if (pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null && (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n      // Speed option is set and no duration => calculate duration based on speed and scroll distance\n      pageScrollInstance.executionDuration = Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n    }\n    // We should go there directly, as our \"animation\" would have one big step\n    // only anyway and this way we save the interval stuff\n    const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n    if (allReadyAtDestination || tooShortInterval) {\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        if (allReadyAtDestination) {\n          console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n        } else {\n          console.log('Scroll duration shorter that interval length, jumping to target');\n        }\n      }\n      pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n      pageScrollInstance.fireEvent(true);\n      return;\n    }\n    if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n      const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition && pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n      if (alreadyInView) {\n        if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n          console.log('Not scrolling, as target already in view');\n        }\n        pageScrollInstance.fireEvent(true);\n        return;\n      }\n    }\n    // Register the interrupt listeners if we want an interruptible scroll animation\n    if (pageScrollInstance.pageScrollOptions.interruptible) {\n      pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n    }\n    // Let's get started, get the start time...\n    pageScrollInstance.startTime = new Date().getTime();\n    // .. and calculate the end time (when we need to finish at last)\n    pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n    pageScrollInstance.timer = setInterval(instance => {\n      // Take the current time\n      const currentTime = new Date().getTime();\n      // Determine the new scroll position\n      let newScrollPosition;\n      let stopNow = false;\n      if (instance.endTime <= currentTime) {\n        // We're over the time already, so go the targetScrollPosition (aka destination)\n        newScrollPosition = instance.targetScrollPosition;\n        stopNow = true;\n      } else {\n        // Calculate the scroll position based on the current time using the easing function\n        newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n      }\n      if (this.config._logLevel >= 5 && isDevMode()) {\n        console.warn('Scroll Position: ' + newScrollPosition);\n      }\n      // Set the new scrollPosition to all scrollViews elements\n      if (!instance.setScrollPosition(newScrollPosition)) {\n        // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n        // early stop the scroll animation to save resources\n        stopNow = true;\n      }\n      // At the end do the internal stop maintenance and fire the pageScrollFinish event\n      // (otherwise the event might arrive at \"too early\")\n      if (stopNow) {\n        this.stopInternal(false, instance);\n      }\n    }, this.config._interval, pageScrollInstance);\n    // Register the instance as running one\n    this.runningInstances.push(pageScrollInstance);\n  }\n  scroll(options) {\n    this.start(this.create(options));\n  }\n  /**\n   * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n   */\n  stopAll(namespace) {\n    if (this.runningInstances.length > 0) {\n      let stoppedSome = false;\n      for (let i = 0; i < this.runningInstances.length; ++i) {\n        const pageScrollInstance = this.runningInstances[i];\n        if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n          stoppedSome = true;\n          this.stopInternal(true, pageScrollInstance);\n          // Decrease the counter, as we removed an item from the array we iterate over\n          i--;\n        }\n      }\n      return stoppedSome;\n    }\n    return false;\n  }\n  stop(pageScrollInstance) {\n    return this.stopInternal(true, pageScrollInstance);\n  }\n}\nPageScrollService.ɵfac = function PageScrollService_Factory(t) {\n  return new (t || PageScrollService)(i0.ɵɵinject(NGXPS_CONFIG));\n};\nPageScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PageScrollService,\n  factory: PageScrollService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PageScrollService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXPS_CONFIG]\n      }]\n    }];\n  }, null);\n})();\nclass NgxPageScrollCoreModule {\n  static forRoot(config) {\n    return {\n      ngModule: NgxPageScrollCoreModule,\n      providers: [PageScrollService, {\n        provide: NGXPS_CONFIG,\n        useValue: config\n      }]\n    };\n  }\n}\nNgxPageScrollCoreModule.ɵfac = function NgxPageScrollCoreModule_Factory(t) {\n  return new (t || NgxPageScrollCoreModule)();\n};\nNgxPageScrollCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPageScrollCoreModule\n});\nNgxPageScrollCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [PageScrollService, {\n    provide: NGXPS_CONFIG,\n    useValue: {}\n  }]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPageScrollCoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [PageScrollService, {\n        provide: NGXPS_CONFIG,\n        useValue: {}\n      }]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };","map":{"version":3,"names":["i0","InjectionToken","isDevMode","Injectable","Inject","NgModule","PageScrollInstance","constructor","pageScrollOptions","startScrollPosition","interruptListenersAttached","timer","scrollViews","length","document","documentElement","body","parentNode","isInlineScrolling","getScrollingTargetPosition","scrollTargetElement","docEl","windowPageYOffset","defaultView","pageYOffset","undefined","windowPageXOffset","pageXOffset","scrollTop","scrollLeft","clientTop","clientLeft","top","left","box","getBoundingClientRect","Math","round","getInlineScrollingTargetPosition","position","offsetTop","offsetLeft","advancedInlineOffsetCalculation","accumulatedParentsPos","theWindow","ownerDocument","parentFound","parent","parentElement","getComputedStyle","getPropertyValue","getScrollPropertyValue","scrollingView","verticalScrolling","getScrollClientPropertyValue","clientWidth","clientHeight","extractScrollTargetPosition","getScrollTargetElement","NaN","getCurrentOffset","scrollOffset","setScrollPosition","reduce","oneAlreadyWorked","startScrollPropertyValue","scrollDistance","abs","isSmallMovement","_minScrollDistance","fireEvent","value","scrollFinishListener","emit","attachInterruptListeners","interruptReporter","detachInterruptListeners","interruptListener","event","report","interruptEvents","forEach","addEventListener","removeEventListener","scrollTarget","targetSelector","match","getElementById","substr","querySelector","NGXPS_CONFIG","defaultPageScrollConfig","_interval","_logLevel","namespace","duration","interruptKeys","interruptible","scrollInView","easingLogic","t","b","c","d","PageScrollService","customConfig","runningInstances","onInterrupted","pageScrollInstance","shouldStop","type","config","indexOf","key","some","contains","target","stopAll","stopInternal","interrupted","index","splice","clearInterval","create","options","start","console","warn","startScrollPositionFound","scrollRange","scrollPosition","pageScrollOffset","scrollTargetPosition","targetScrollPosition","distanceToScroll","isNaN","log","allReadyAtDestination","executionDuration","speed","tooShortInterval","alreadyInView","startTime","Date","getTime","endTime","setInterval","instance","currentTime","newScrollPosition","stopNow","push","scroll","stoppedSome","i","stop","ɵfac","ɵprov","args","providedIn","decorators","NgxPageScrollCoreModule","forRoot","ngModule","providers","provide","useValue","ɵmod","ɵinj"],"sources":["D:/POC _ E_COMMERCE/E_COMMERCE/code/Frontend/node_modules/ngx-page-scroll-core/fesm2020/ngx-page-scroll-core.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Injectable, Inject, NgModule } from '@angular/core';\n\n/**\n * Represents a scrolling action\n */\nclass PageScrollInstance {\n    /**\n     * Private constructor, requires the properties assumed to be the bare minimum.\n     * Use the factory methods to create instances:\n     *      {@link PageScrollService#create}\n     */\n    constructor(pageScrollOptions) {\n        /**\n         * These properties will be set/manipulated if the scroll animation starts\n         */\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n        this.startScrollPosition = 0;\n        /* Whether an interrupt listener is attached to the body or not */\n        this.interruptListenersAttached = false;\n        /* References to the timer instance that is used to perform the scroll animation to be\n         able to clear it on animation end*/\n        this.timer = null;\n        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n            pageScrollOptions.scrollViews = [\n                pageScrollOptions.document.documentElement,\n                pageScrollOptions.document.body,\n                pageScrollOptions.document.body.parentNode,\n            ];\n            this.isInlineScrolling = false;\n        }\n        else {\n            this.isInlineScrolling = true;\n        }\n        this.pageScrollOptions = pageScrollOptions;\n    }\n    static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const body = pageScrollOptions.document.body;\n        const docEl = pageScrollOptions.document.documentElement;\n        const windowPageYOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageYOffset || undefined;\n        const windowPageXOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageXOffset || undefined;\n        const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n        const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n        const clientTop = docEl.clientTop || body.clientTop || 0;\n        const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n        if (scrollTargetElement === undefined || scrollTargetElement === null) {\n            // No element found, so return the current position to not cause any change in scroll position\n            return { top: scrollTop, left: scrollLeft };\n        }\n        const box = scrollTargetElement.getBoundingClientRect();\n        const top = box.top + scrollTop - clientTop;\n        const left = box.left + scrollLeft - clientLeft;\n        return { top: Math.round(top), left: Math.round(left) };\n    }\n    static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\n        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n            const accumulatedParentsPos = { top: 0, left: 0 };\n            // not named window to make sure we're not getting the global window variable by accident\n            const theWindow = scrollTargetElement.ownerDocument.defaultView;\n            let parentFound = false;\n            // Start parent is the immediate parent\n            let parent = scrollTargetElement.parentElement;\n            // Iterate upwards all parents\n            while (!parentFound && parent !== undefined && parent !== null) {\n                if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n                    accumulatedParentsPos.top += parent.offsetTop;\n                    accumulatedParentsPos.left += parent.offsetLeft;\n                }\n                // Next iteration\n                parent = parent.parentElement;\n                parentFound = parent === pageScrollOptions.scrollViews[0];\n            }\n            if (parentFound) {\n                // Only use the results if we found the parent, otherwise we accumulated too much anyway\n                position.top += accumulatedParentsPos.top;\n                position.left += accumulatedParentsPos.left;\n            }\n            else {\n                /* TODO Uncomment\n                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                  console.warn('Unable to find nested scrolling targets parent!');\n                }*/\n            }\n        }\n        return position;\n    }\n    getScrollPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.scrollLeft;\n        }\n        return scrollingView.scrollTop;\n    }\n    getScrollClientPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.clientWidth;\n        }\n        return scrollingView.clientHeight;\n    }\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     */\n    extractScrollTargetPosition() {\n        const scrollTargetElement = this.getScrollTargetElement();\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\n            // Scroll target not found\n            return { top: NaN, left: NaN };\n        }\n        if (this.isInlineScrolling) {\n            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n        }\n        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     */\n    getCurrentOffset() {\n        return this.pageScrollOptions.scrollOffset;\n    }\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    setScrollPosition(position) {\n        // Set the new scrollTop/scrollLeft to all scrollViews elements\n        return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n            const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n                const scrollDistance = Math.abs(startScrollPropertyValue - position);\n                // The movement we need to perform is less than 2px\n                // This we consider a small movement which some browser may not perform when\n                // changing the scrollTop/scrollLeft property\n                // Thus in this cases we do not stop the scroll animation, although setting the\n                // scrollTop/scrollLeft value \"fails\"\n                const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n                if (!this.pageScrollOptions.verticalScrolling) {\n                    scrollingView.scrollLeft = position;\n                }\n                else {\n                    scrollingView.scrollTop = position;\n                }\n                // Return true if setting the new scrollTop/scrollLeft value worked\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n                // set due to dpi or rounding irregularities)\n                if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n                    return true;\n                }\n            }\n            return oneAlreadyWorked;\n        }, false);\n    }\n    /**\n     * Trigger firing a animation finish event\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\n     */\n    fireEvent(value) {\n        if (this.pageScrollOptions.scrollFinishListener) {\n            this.pageScrollOptions.scrollFinishListener.emit(value);\n        }\n    }\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     */\n    attachInterruptListeners(interruptReporter) {\n        if (this.interruptListenersAttached) {\n            // Detach possibly existing listeners first\n            this.detachInterruptListeners();\n        }\n        this.interruptListener = (event) => {\n            interruptReporter.report(event, this);\n        };\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = true;\n    }\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     */\n    detachInterruptListeners() {\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = false;\n    }\n    getScrollTargetElement() {\n        if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n            const targetSelector = this.pageScrollOptions.scrollTarget;\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n                // It's an id selector and a valid id, as it does not contain any white space characters\n                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n            }\n            return this.pageScrollOptions.document.querySelector(targetSelector);\n        }\n        return this.pageScrollOptions.scrollTarget;\n    }\n}\n\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst defaultPageScrollConfig = {\n    _interval: 10,\n    _minScrollDistance: 2,\n    _logLevel: 1,\n    namespace: 'default',\n    verticalScrolling: true,\n    duration: 1250,\n    scrollOffset: 0,\n    advancedInlineOffsetCalculation: false,\n    interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n    interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n    interruptible: true,\n    scrollInView: true,\n    easingLogic: (t, b, c, d) => {\n        // Linear easing\n        return c * t / d + b;\n    },\n};\n\nclass PageScrollService {\n    constructor(customConfig) {\n        this.runningInstances = [];\n        this.onInterrupted = {\n            report: (event, pageScrollInstance) => {\n                if (!pageScrollInstance.pageScrollOptions.interruptible) {\n                    // Non-interruptible anyway, so do not stop anything\n                    return;\n                }\n                let shouldStop = true;\n                if (event.type === 'keyup') {\n                    // Only stop if specific keys have been pressed, for all others don't stop anything\n                    if (this.config.interruptKeys.indexOf(event.key) === -1) {\n                        // The pressed key is not in the list of interrupting keys\n                        shouldStop = false;\n                    }\n                }\n                else if (event.type === 'mousedown') {\n                    // For mousedown events we only stop the scroll animation of the mouse has\n                    // been clicked inside the scrolling container\n                    if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n                        // Mouse clicked an element which is not inside any of the the scrolling containers\n                        shouldStop = false;\n                    }\n                }\n                if (shouldStop) {\n                    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n                }\n            },\n        };\n        this.config = { ...defaultPageScrollConfig, ...customConfig };\n    }\n    stopInternal(interrupted, pageScrollInstance) {\n        const index = this.runningInstances.indexOf(pageScrollInstance);\n        if (index >= 0) {\n            this.runningInstances.splice(index, 1);\n        }\n        if (pageScrollInstance.interruptListenersAttached) {\n            pageScrollInstance.detachInterruptListeners();\n        }\n        if (pageScrollInstance.timer) {\n            // Clear/Stop the timer\n            clearInterval(pageScrollInstance.timer);\n            // Clear the reference to this timer\n            pageScrollInstance.timer = undefined;\n            pageScrollInstance.fireEvent(!interrupted);\n            return true;\n        }\n        return false;\n    }\n    create(options) {\n        return new PageScrollInstance({ ...this.config, ...options });\n    }\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    start(pageScrollInstance) {\n        // Merge the default options in the pageScrollInstance options\n        pageScrollInstance.pageScrollOptions = { ...this.config, ...pageScrollInstance.pageScrollOptions };\n        // Stop all possibly running scroll animations in the same namespace\n        this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n            // No scrollViews specified, thus we can't animate anything\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n            }\n            return;\n        }\n        let startScrollPositionFound = false;\n        let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]);\n        // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n        pageScrollInstance.startScrollPosition = 0;\n        // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n        pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n            if (scrollingView === undefined || scrollingView === null) {\n                return;\n            }\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\n            const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n            if (!startScrollPositionFound && scrollPosition) {\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\n                // Return the scroll position value, as this will be our startScrollPosition\n                pageScrollInstance.startScrollPosition = scrollPosition;\n                startScrollPositionFound = true;\n                // Remember te scrollRange of this scrollingView\n                scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n            }\n        });\n        const pageScrollOffset = pageScrollInstance.getCurrentOffset();\n        // Calculate the target position that the scroll animation should go to\n        const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n        // Calculate the distance we need to go in total\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\n            // We weren't able to find the target position, maybe the element does not exist?\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\n            }\n            pageScrollInstance.fireEvent(false);\n            return;\n        }\n        // We're at the final destination already\n        // OR we need to scroll down but are already at the end\n        // OR we need to scroll up but are at the top already\n        const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;\n        // Check how long we need to scroll if a speed option is given\n        // Default executionDuration is the specified duration\n        pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;\n        // Maybe we need to pay attention to the speed option?\n        if ((pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null) &&\n            (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\n            pageScrollInstance.executionDuration =\n                Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n        }\n        // We should go there directly, as our \"animation\" would have one big step\n        // only anyway and this way we save the interval stuff\n        const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n        if (allReadyAtDestination || tooShortInterval) {\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                if (allReadyAtDestination) {\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n                }\n                else {\n                    console.log('Scroll duration shorter that interval length, jumping to target');\n                }\n            }\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n            pageScrollInstance.fireEvent(true);\n            return;\n        }\n        if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n            const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition &&\n                pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n            if (alreadyInView) {\n                if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                    console.log('Not scrolling, as target already in view');\n                }\n                pageScrollInstance.fireEvent(true);\n                return;\n            }\n        }\n        // Register the interrupt listeners if we want an interruptible scroll animation\n        if (pageScrollInstance.pageScrollOptions.interruptible) {\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n        }\n        // Let's get started, get the start time...\n        pageScrollInstance.startTime = new Date().getTime();\n        // .. and calculate the end time (when we need to finish at last)\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n        pageScrollInstance.timer = setInterval((instance) => {\n            // Take the current time\n            const currentTime = new Date().getTime();\n            // Determine the new scroll position\n            let newScrollPosition;\n            let stopNow = false;\n            if (instance.endTime <= currentTime) {\n                // We're over the time already, so go the targetScrollPosition (aka destination)\n                newScrollPosition = instance.targetScrollPosition;\n                stopNow = true;\n            }\n            else {\n                // Calculate the scroll position based on the current time using the easing function\n                newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n            }\n            if (this.config._logLevel >= 5 && isDevMode()) {\n                console.warn('Scroll Position: ' + newScrollPosition);\n            }\n            // Set the new scrollPosition to all scrollViews elements\n            if (!instance.setScrollPosition(newScrollPosition)) {\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n                // early stop the scroll animation to save resources\n                stopNow = true;\n            }\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\n            // (otherwise the event might arrive at \"too early\")\n            if (stopNow) {\n                this.stopInternal(false, instance);\n            }\n        }, this.config._interval, pageScrollInstance);\n        // Register the instance as running one\n        this.runningInstances.push(pageScrollInstance);\n    }\n    scroll(options) {\n        this.start(this.create(options));\n    }\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     */\n    stopAll(namespace) {\n        if (this.runningInstances.length > 0) {\n            let stoppedSome = false;\n            for (let i = 0; i < this.runningInstances.length; ++i) {\n                const pageScrollInstance = this.runningInstances[i];\n                if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n                    stoppedSome = true;\n                    this.stopInternal(true, pageScrollInstance);\n                    // Decrease the counter, as we removed an item from the array we iterate over\n                    i--;\n                }\n            }\n            return stoppedSome;\n        }\n        return false;\n    }\n    stop(pageScrollInstance) {\n        return this.stopInternal(true, pageScrollInstance);\n    }\n}\nPageScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: PageScrollService, deps: [{ token: NGXPS_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nPageScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: PageScrollService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: PageScrollService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXPS_CONFIG]\n                }] }]; } });\n\nclass NgxPageScrollCoreModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxPageScrollCoreModule,\n            providers: [PageScrollService, { provide: NGXPS_CONFIG, useValue: config }],\n        };\n    }\n}\nNgxPageScrollCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: NgxPageScrollCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPageScrollCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.1\", ngImport: i0, type: NgxPageScrollCoreModule });\nNgxPageScrollCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: NgxPageScrollCoreModule, providers: [\n        PageScrollService,\n        { provide: NGXPS_CONFIG, useValue: {} },\n    ] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: NgxPageScrollCoreModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        PageScrollService,\n                        { provide: NGXPS_CONFIG, useValue: {} },\n                    ],\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}